<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>myaath&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://myaath.github.io/"/>
  <updated>2019-12-31T05:14:06.036Z</updated>
  <id>https://myaath.github.io/</id>
  
  <author>
    <name>myaath</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VSCode</title>
    <link href="https://myaath.github.io/2019/08/02/VSCode/"/>
    <id>https://myaath.github.io/2019/08/02/VSCode/</id>
    <published>2019-08-02T05:11:42.000Z</published>
    <updated>2019-12-31T05:14:06.036Z</updated>
    
    <content type="html"><![CDATA[<h4 id="VSCode命令行"><a href="#VSCode命令行" class="headerlink" title="VSCode命令行"></a>VSCode命令行</h4><ol><li>code -r -g package.json:128 当前窗口打开文件第128行</li><li>code -r -d a.txt b.txt 当前窗口对比两个文件</li><li>ls | code -r - 当前窗口显示当前目录下所有文件名  </li></ol><h4 id="编辑模式快捷键"><a href="#编辑模式快捷键" class="headerlink" title="编辑模式快捷键"></a>编辑模式快捷键</h4><blockquote><p>Ctrl + Enter 向下另起<br>Ctrl + Shift + Enter 向上另起<br>Ctrl + U 撤销光标的移动和选择<br>Alt + 上下方向键  移动当前行<br>Alt + shift + 上下方向键  复制到上面</p></blockquote><blockquote><p>Shift + Alt + F 代码段自动对齐<br>Ctrl+U +Ctrl+I 按升序排列行</p></blockquote><blockquote><p>Ctrl+Alt+O 在浏览器中打开<br>Ctrl + Alt + N/M 运行/停止代码</p></blockquote><blockquote><p>Ctrl + W + E 快速切换窗口<br>Ctrl + R 打开最近的文件</p></blockquote><h5 id="创建多个光标"><a href="#创建多个光标" class="headerlink" title="创建多个光标"></a>创建多个光标</h5><blockquote><p>Alt + 点击 <strong>or</strong> Ctrl + Alt + 下方向键</p></blockquote><h5 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h5><blockquote><p>Ctrl + P：11 查找文件打开第11行<br>Ctrl + Enter 分窗口开打文件<br>Ctrl + Shift + O 跳转函数或者标识符（@：分类显示）<br>Ctrl + T 显示不同文件的符号<br>F12 转到定义<br>Ctrl + F12 跳转到实现<br>Shift + F12 显示引用<br>Ctrl + 空格键 建议列表<br>Ctrl + Shift + Space 参数列表<br>Ctrl + .  快速修复建议列表<br>F2 重构改名  </p></blockquote><h5 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h5><ul><li>打开命令面板，搜索“配置用户代码片段”（Configure User Snippets）并且执行</li><li>Tab Stop，意思是，当我们按下 Tab 键之后，光标移动到的位置eg：$1（将光标移动到上一个 Tab Stop 的位置的快捷键 Shift + Tab）</li><li>占位符，顾名思义，这个值是我们在代码片段中预先设置好的 eg：${1:label} </li><li>多光标，代码片段中三个不同的位置插入 $1，这样编辑器就会为这三个不同的位置，分别创建一个光标，然后当我们打字的时候，他们就会被一起修改</li><li><a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets#_variables" target="_blank" rel="noopener">预设变量</a> ，与上下文相关的占位符eg： ${1:$CLIPBOARD}（使用剪切板的内容）</li></ul><h5 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h5><p>// region Main 申明了一个可折叠代码块的开始，而// endregion则申明了这段可折叠代码的结束  </p><h4 id="VIM补充"><a href="#VIM补充" class="headerlink" title="VIM补充"></a>VIM补充</h4><ol><li>%: 跳到对应的(, (, [ 处.</li><li>*(对比#) : 跳到当前光标的下一个(上一个) 相同单词的地方</li><li>“+p/y 系统剪切板</li><li>gcc注释</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;VSCode命令行&quot;&gt;&lt;a href=&quot;#VSCode命令行&quot; class=&quot;headerlink&quot; title=&quot;VSCode命令行&quot;&gt;&lt;/a&gt;VSCode命令行&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;code -r -g package.json:128 当前窗口打开文件
      
    
    </summary>
    
    
      <category term="工具" scheme="https://myaath.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://myaath.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据分析</title>
    <link href="https://myaath.github.io/2019/02/16/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>https://myaath.github.io/2019/02/16/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</id>
    <published>2019-02-16T05:31:30.000Z</published>
    <updated>2019-12-31T05:38:24.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><ol><li>培养兴趣：兴趣是最好的老师，我们大自然的很多科学都是和数学相关，比如为什么雪花是六边形？</li><li>刻意训练：你不需要通过做项目来做完整的数学训练，比如你和朋友去吃饭的时候，你可以脑算下一共花了多少钱？很多时候，心算是数学的一个能力</li><li>价值暗示：数学可以帮你很多，尤其是在算法效率、代码质量上。很明显，数学好的人，写出来的算法效率也更高。所以一个代码完成后，你可以问自己个问题：还有没有更好的方法？</li></ol><p>MAS 方法  </p><ul><li>Multi-Dimension：想要掌握一个事物，就要从多个角度去认识它。</li><li>Ask：不懂就问，程序要大多很害羞，突破这一点，不懂就问最重要</li><li>Sharing：最好的学习就是分享。用自己的语言讲出来，是对知识的进一步梳理</li></ul><p><strong><em>学习数据分析的核心就是培养数据思维，掌握挖掘工具，熟练实践并积累经验</em></strong></p><h3 id="数据分析的过程"><a href="#数据分析的过程" class="headerlink" title="数据分析的过程"></a>数据分析的过程</h3><p>当我们谈论数据分析的时候，都在讲些什么呢？这里我可以把数据分成三个重要的组成部分</p><ol><li>数据采集，接地气</li><li>数据挖掘，核心商业价值</li><li>数据可视化，万金油</li></ol><p>数据挖掘的六个步骤：</p><ol><li>商业理解</li><li>数据理解</li><li>数据准备</li><li>模型建立</li><li>模型评估</li><li>上线发布</li></ol><p>数据挖掘的十大算法：<br>分类算法：C4.5，朴素贝叶斯（Naive Bayes），SVM， KNN， Adaboost， CART<br>聚类算法：K-Mean， EM<br>关联分析：Apriori<br>连接分析：PageRank  </p><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><h4 id="1-python"><a href="#1-python" class="headerlink" title="1.python"></a>1.python</h4><p>这里推荐一些教程<br>入门：  </p><ol><li>廖雪峰的python教程 <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000</a></li><li>《python编程从入门到实践》</li></ol><p>进阶：  </p><ol><li>《流畅的python》</li><li>《python数据科学手册》</li></ol><p>练习：  </p><ol><li>Kaggle</li><li>LeetCode</li><li>codewar</li></ol><p>PS:当你发现python的速度不能满足你的需求的时候，可以考虑使用C或者Julia</p><h4 id="2-Numpy"><a href="#2-Numpy" class="headerlink" title="2.Numpy"></a>2.Numpy</h4><p><strong>为什么选择numpy？</strong><br>这里给大家解释一下为什么我们选择python来进行数据处理，python的列表其本质是C语言中的结构体，拿python中的一个整型的 <strong>a = 4</strong> 来说，它实际上包含四部分：<strong>引用计数（处理内存分配和回收），类型编码，数据大小，实际值。</strong> python是一种弱类型语言，不需要去声明变量的类型，使用起来十分灵活，python的list也可以装填不同类型的值，这样做的代价便是牺牲了速度，而Numpy的array限制了其中存储值得类型，使其统一，在底层做了优化，大大提升了速度。<br>一般来说，python列表在进行运算时，会先检查对象的类型，并且动态查找可以使用该数据类型的正确函数，效率比较低，numpy提供了很多通用函数（universal function），是numpy中向量操作的实现，其使命是加快对可迭代对象的逐元素操作。  </p><p><strong>通用函数高级特性</strong>  </p><ol><li>所有的通用函数都可以通过out参数来指定计算结果的存放位置，这样可以有效节约内存</li><li>大多数的聚合都有对NaN值得安全处理，计算时会忽略所有的确实值</li></ol><h4 id="3-Pandas"><a href="#3-Pandas" class="headerlink" title="3.Pandas"></a>3.Pandas</h4><p>Kaggle练习  <a href="https://www.kaggle.com/learn/pandas" target="_blank" rel="noopener">https://www.kaggle.com/learn/pandas</a></p><h4 id="4-用户画像"><a href="#4-用户画像" class="headerlink" title="4.用户画像"></a>4.用户画像</h4><p><strong>锻炼自己的抽象能力，将繁杂的事务简单化</strong><br><strong>我们的最终目的不是处理这些数据，而是理解、使用这些数据挖掘的结果</strong>  </p><p>用户画像准则：都是谁，从哪来，到哪去<br>用户画像建模：</p><ol><li>统一化 <strong>用户唯一标识是整个用户画像的核心</strong>  </li><li>标签化 <strong>用户消费行为分析</strong><br>2.1 用户标签：它包括了性别、年龄、地域、收入、学历、职业等。这些包括了用户的基础属性。<br>2.2 消费标签：消费习惯、购买意向、是否对促销敏感。这些统计分析用户的消费习惯。<br>2.3 行为标签：时间段、频次、时长、访问路径。这些是通过分析用户行为，来得到他们使用 App 的习惯。<br>2.4内容分析：对用户平时浏览的内容，尤其是停留时间长、浏览次数多的内容进行分析，分析出用户对哪些内容感兴趣，比如，金融、娱乐、教育、体育、科技、时尚等。</li><li>业务化 <strong>获客、粘客和留客</strong><br><strong>在获客上</strong>，我们可以找到优势的宣传渠道，如何通过个性化的宣传手段，吸引有潜在需求的用户，并刺激其转化。<br><strong>在粘客上</strong>，如何提升用户的单价和消费频次，方法可以包括购买后的个性化推荐、针对优质用户进行优质高价商品的推荐、以及重复购买，比如通过红包、优惠等方式激励对优惠敏感的人群，提升购买频次。<br><strong>在留客上</strong>，预测用户是否可能会从平台上流失。在营销领域，关于用户留存有一个观点——如果将顾客流失率降低 5%，公司利润将提升 25%~85%。可以看出留存率是多么的重要。用户流失可能会包括多种情况，比如用户体验、竞争对手、需求变化等，通过预测用户的流失率可以大幅降低用户留存的运营成本。</li></ol><h4 id="5-数据采集"><a href="#5-数据采集" class="headerlink" title="5.数据采集"></a>5.数据采集</h4><p>数据源：开放数据源，爬虫爬取，日志采集，传感器</p><h4 id="6-八爪鱼"><a href="#6-八爪鱼" class="headerlink" title="6.八爪鱼"></a>6.八爪鱼</h4><h4 id="7-爬虫"><a href="#7-爬虫" class="headerlink" title="7.爬虫"></a>7.爬虫</h4><h4 id="8-数据清洗"><a href="#8-数据清洗" class="headerlink" title="8.数据清洗"></a>8.数据清洗</h4><p><strong>好的数据分析师必定是一名数据清洗高手，要知道在整个数据分析过程中，不论是时间还是功夫上，数据清洗大概都占到了80%。</strong>  </p><ol><li><p>收集整理数据一定要做标注  </p></li><li><p>完整性：单条数据是否存在空值，统计的字段是否完善。<strong>空值：删除记录，平均填充，高频填充；空行：删除</strong></p></li><li><p>全面性：观察某一列的全部数值，比如在Excel表中，我们选中一列，可以看到该列的平均值、最大值、最小值。我们可以通过常识来判断该列是否有问题，比如：数据定义、单位标识、数值本身。  <strong>统一单位</strong></p></li><li><p>合法性：数据的类型、内容、大小的合法性。比如数据中存在非ASCII字符，性别存在了未知，年龄超过了 150 岁等。  <strong>非ASCII字符：替换，删除</strong></p></li><li><p>唯一性：数据是否存在重复记录，因为数据通常来自不同渠道的汇总，重复的情况是常见的。行数据、列数据都需要是唯一的，比如一个人不能重复记录多次，且一个人的体重也不能在列指标中重复记录多次。 <strong>一列含有多个参数：拆分新列；记录重复：删除</strong></p></li></ol><p><strong>1.数据要标准、干净、连续<br>2.养成数据审核的习惯<br>3.没有高质量的数据，就没有高质量的数据挖掘，而数据清洗是高质量数据的一道保障</strong></p><h4 id="9-数据集成"><a href="#9-数据集成" class="headerlink" title="9.数据集成"></a>9.数据集成</h4><h4 id="10-数据变换"><a href="#10-数据变换" class="headerlink" title="10.数据变换"></a>10.数据变换</h4><p>数据变换是数据准备的重要环节，它<strong>通过数据平滑、数据聚集、数据概化和规范化等方式</strong>将数据转换成适合于数据挖掘的形式。</p><ol><li>数据平滑：去除数据中的噪声，将连续数据离散化。这里可以采用分箱、聚类和回归的方式进行数据平滑</li><li>数据聚合：对数据进行汇总，在 SQL 中有一些聚集函数可以供我们操作，比如 Max() 反馈某个字段的数值最大值，Sum() 返回某个字段的数值总和</li><li>数据概化：将数据由较低的概念抽象成为较高的概念，减少数据复杂度，即用更高的概念替代更低的概念。比如说上海、杭州、深圳、北京可以概化为中国</li><li>数据规范化：使属性数据按比例缩放，这样就将原来的数值映射到一个新的特定区域中。常用的方法有最小—最大规范化、Z—score规范化、按小数定标规范化等，我会在后面给你讲到这些方法的使用</li><li>属性构造：构造出新的属性并添加到属性集中。这里会用到特征工程的知识，因为通过属性与属性的连接构造新的属性，其实就是特征工程。比如说，数据表中统计每个人的英语、语文和数学成绩，你可以构造一个“总和”这个属性，来作为新属性。这样“总和”这个属性就可以用到后续的数据挖掘计算中</li></ol><p><strong>数据规范化的方式</strong>：</p><ol><li>Max-min规范化  新数值 =（原数值 - 极小值）/（极大值 - 极小值）</li><li>Z-Score规范化  新数值 =（原数值 - 均值）/ 标准差</li><li>小数定标规范化  小数定标规范化就是通过移动小数点的位置来进行规范化。小数点移动多少位取决于属性 A 的取值中的最大绝对值</li></ol><h4 id="11-数据可视化"><a href="#11-数据可视化" class="headerlink" title="11.数据可视化"></a>11.数据可视化</h4><p>按照数据之间的关系，我们可以把可视化视图划分为4类，它们分别是比较、联系、构成和分布。四种关系的特点：<br>比较：比较数据间各类别的关系，或者是它们随着时间的变化趋势，比如折线图；<br>联系：查看两个或两个以上变量之间的关系，比如散点图；<br>构成：每个部分占整体的百分比，或者是随着时间的百分比变化，比如饼图；<br>分布：关注单个变量，或者多个变量的分布情况，比如直方图。</p><p><strong>散点图</strong>：将两个变量的值显示再二维坐标中，非常适合展示两个变量之间的关系<br><strong>折线图</strong>：用来表示数据随着时间变化的趋势<br><strong>直方图</strong>：把横坐标等分成了一定数量的小区间，展示了数据的数值分布<br><strong>条形图</strong>：查看类别的特征<br><strong>箱线图</strong>：分析数据的差异性，离散程度和异常值等<br><strong>饼图</strong>：显示每个不分大小与总和之间的比例<br><strong>热力图</strong>：直观分析多元变量<br><strong>蜘蛛图</strong>：显示一对多关系<br><strong>二元变量分布</strong>：查看两个变量之间的关系<br><strong>成对关系</strong>：查看变量对之间的关系</p><h3 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h3><h4 id="1-决策树"><a href="#1-决策树" class="headerlink" title="1.决策树"></a>1.决策树</h4><p><strong>信息熵</strong>：给定集合的纯净程度，信息熵越大，信息量越大<br><strong>信息增益</strong>：信息增益代表了在一个条件下，信息复杂度（不确定性）减少的程度，如果信息增益大的话那么这个特征对于分类来说很关键</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;学习方法&quot;&gt;&lt;a href=&quot;#学习方法&quot; class=&quot;headerlink&quot; title=&quot;学习方法&quot;&gt;&lt;/a&gt;学习方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;培养兴趣：兴趣是最好的老师，我们大自然的很多科学都是和数学相关，比如为什么雪花是六边形？&lt;/li&gt;
&lt;li&gt;刻意
      
    
    </summary>
    
    
      <category term="Data" scheme="https://myaath.github.io/categories/Data/"/>
    
    
      <category term="Data Analysis" scheme="https://myaath.github.io/tags/Data-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>精益数据分析</title>
    <link href="https://myaath.github.io/2019/01/18/%E7%B2%BE%E7%9B%8A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>https://myaath.github.io/2019/01/18/%E7%B2%BE%E7%9B%8A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</id>
    <published>2019-01-18T05:36:46.000Z</published>
    <updated>2019-12-31T05:39:30.273Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>1.不要销售你能制造得产品，而是制造你能卖出去的产品<br>2.理清商业模式和增长阶段，找出第一关键指标<br>3.创业公司是一种组织，其存在的目的就是寻找可规模化和可重复的商业模式  </p><hr><h3 id="一、别再欺骗自己了"><a href="#一、别再欺骗自己了" class="headerlink" title="一、别再欺骗自己了"></a>一、别再欺骗自己了</h3><p>1.你无法衡量的东西，你也无法管理<br>2.最小可行化产品  </p><hr><h3 id="二、创业的记分牌"><a href="#二、创业的记分牌" class="headerlink" title="二、创业的记分牌"></a>二、创业的记分牌</h3><p>什么是好的数据指标<br>As：是比较性的，简单易懂的，是一个比率</p><p><strong>找出的数据指标：</strong><br>1.定性指标与量化指标<br>2.虚荣指标与可付诸行动的指标<br>3.探索性指标与报告性指标<br>4.先见性指标与后见性指标<br>5.相关性指标与因果性指标  </p><p><strong>8个需要堤防的虚荣数据指标</strong></p><ol><li>点击量</li><li>页面浏览量（PV值）</li><li>访问量</li><li>独立访客数</li><li>粉丝/好友/赞的数量</li><li>网站停留时间（time on site）/浏览页数（number of pages）</li><li>收集到的用户邮件地址数量</li><li>下载量</li></ol><p>发现相关性可以帮助你预测未来，发现因果关系意味着你可以改变未来</p><p>启示：</p><ol><li>了解你的客户，没有比与他们直接对话更有效的手段了</li><li>尽早做出一些假设并定下你认为可称为成功的目标</li></ol><p><strong>测试时数据分析的灵魂</strong><br>测试可以通过市场细分，同期群分析，A/B测试来比较两个样本的不同<br>市场细分：找出一群拥有共同特征的人<br>同期群分析：比较相似群体随时间的变化<br>A/B和多变量测试：同一时间段对不同群体的研究</p><hr><h3 id="三、你把生命献给谁"><a href="#三、你把生命献给谁" class="headerlink" title="三、你把生命献给谁"></a>三、你把生命献给谁</h3><p>一个不存在的市场不会在乎你有多聪明<br>永远不要进入自己没有优势的领域，否则强敌环伺，举步维艰</p><p><strong>精益画布</strong><br><a href="http://leancanvas.com" target="_blank" rel="noopener">http://leancanvas.com</a></p><hr><h3 id="四、以数据为导向与通过数据获取信息"><a href="#四、以数据为导向与通过数据获取信息" class="headerlink" title="四、以数据为导向与通过数据获取信息"></a>四、以数据为导向与通过数据获取信息</h3><p>人类提供灵感，机器负责验证<br>渐进式的改变可以达到局部极限，创新则可能导致全局洗牌  </p><p><strong>数据科学家的思维方式</strong><br>十个圈套：</p><ol><li>假设数据没有噪声  判断数据是否有效</li><li>忘记归一化</li><li>排除异常点</li><li>包括异常点</li><li>忽视季节性</li><li>抛开基数侈谈增长</li><li>数据呕吐（关键数据）</li><li>谎报军情的指标（报警指标过于敏感）</li><li>“不是在这收集的”综合征</li><li>关注噪声（把虚荣指标放一边）</li></ol><hr><h3 id="五、数据分析框架"><a href="#五、数据分析框架" class="headerlink" title="五、数据分析框架"></a>五、数据分析框架</h3><p>海盗指标：<br>获取用户，提高活跃度，提高留存率，获取营收，自传播  </p><p>增长引擎：黏着式增长，病毒式增长，付费式增长</p><hr><h3 id="六、第一关键指标的约束力"><a href="#六、第一关键指标的约束力" class="headerlink" title="六、第一关键指标的约束力"></a>六、第一关键指标的约束力</h3><p>挑选一个唯一指标，该指标对你当前所处的创业阶段无比重要，第一关键指标OMTM（One Metric That Matters）  </p><hr><h3 id="七、你所在的商业领域"><a href="#七、你所在的商业领域" class="headerlink" title="七、你所在的商业领域"></a>七、你所在的商业领域</h3><p>营销就是更频繁地向更能多人销售更多的商品，从而更有效率地赚到更多的钱  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;1.不要销售你能制造得产品，而是制造你能卖出去的产品&lt;br&gt;2.理清商业模式和增长阶段，找出第一关键指标&lt;br&gt;3.创业公司是一种组织，其存
      
    
    </summary>
    
    
      <category term="Data" scheme="https://myaath.github.io/categories/Data/"/>
    
    
      <category term="Data Analysis" scheme="https://myaath.github.io/tags/Data-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python</title>
    <link href="https://myaath.github.io/2018/02/05/Fluent-Python/"/>
    <id>https://myaath.github.io/2018/02/05/Fluent-Python/</id>
    <published>2018-02-05T02:16:04.000Z</published>
    <updated>2019-12-31T05:38:25.685Z</updated>
    
    <content type="html"><![CDATA[<p>在进行了一些Leetcode的练习后发觉，python相比我之前学习的C、Java更为方便，如沐春风，不管是从数据结构还是从设计的哲学，我体会到了Python语言的强大，买来一本《Fluent Python》，希望自己在读完后有更深刻的理解</p><h2 id="第一部分-序幕"><a href="#第一部分-序幕" class="headerlink" title="第一部分  序幕"></a>第一部分  序幕</h2><h3 id="第1章-Python数据模型"><a href="#第1章-Python数据模型" class="headerlink" title="第1章  Python数据模型"></a>第1章  Python数据模型</h3><blockquote><p>Guido对语言设计美学的深入理解让人震惊。我认识不少很不错的编程语言设计者，他们设计出来的东西确实精彩，但是从来都不会有用户。Guido知道如何在理论上做出一定妥协，设计出来的语言让使用者觉得如沐春风，这真是不可多得。</p></blockquote><p align="right">——Jim Hugunin<br>Jython的作者, AspectJ的作者之一, .NET DLR架构师</p>  <p>第一章可以说是一个引子，主要在讲python的数据模型（data model），同时讲了Python的特殊方法（也称dunder method）并以此来描述其一致性。</p><p>数据模型其实是对Python框架的描述，它规范了这门语言自身构建模块的接口，这些模块包括但不限于序列、迭代器、函数、类和上下文管理器，而数据模型所描述的API，为使用最地道的的语言特性来构建你自己的对象提供了工具。</p><h4 id="1-1-一摞Python风格的纸牌"><a href="#1-1-一摞Python风格的纸牌" class="headerlink" title="1.1 一摞Python风格的纸牌"></a>1.1 一摞Python风格的纸牌</h4><blockquote><p>示例 1-1   一摞有序的纸牌  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])  </span><br><span class="line"><span class="comment">#namedtuple可以用属性索引，用于构建只有少数属性但是没有方法的对象</span></span><br><span class="line"><span class="comment">#Card既是Card类型也是tuple类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span>  <span class="comment">#法式扑克牌</span></span><br><span class="line">  ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">  suits = <span class="string">'spades diamonds clubs hearte'</span>.split()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._cards = [Caed(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">    <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure><p>下面我们对已经写好的类进行一些操作，我们可以看到作为类的用户，不必去记住标准操作的格式名称，同时可以方便地利用python的标准库，极其方便。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deck = FrenchDeck()</span><br><span class="line">len(deck) <span class="comment">#一摞牌有多少张</span></span><br><span class="line">&gt;&gt; <span class="number">52</span></span><br><span class="line"></span><br><span class="line">deck[<span class="number">0</span>] <span class="comment">#第一张牌</span></span><br><span class="line">&gt;&gt; Card(rank = <span class="string">'3'</span>, suit = <span class="string">'spades'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice <span class="comment">#从一个序列中随机抽取一个元素</span></span><br><span class="line">choice(deck) <span class="comment">#随机抽一张牌</span></span><br><span class="line">&gt;&gt;  Card(rank = <span class="string">'4'</span>, suit = <span class="string">'clubs'</span>)</span><br><span class="line"></span><br><span class="line">deck[:<span class="number">3</span>]</span><br><span class="line">&gt;&gt; Card(rank = <span class="string">'2'</span>, suit = <span class="string">'spades'</span>), Card(rank = <span class="string">'3'</span>, suit = <span class="string">'spades'</span>), Card(rank = <span class="string">'4'</span>, suit = <span class="string">'spades'</span>)</span><br><span class="line"><span class="comment"># 因为__getitem__方法把[]操作交给了self._cards列表，所以deck自动支持切片操作，同时也可以进行迭代和反向迭代</span></span><br></pre></td></tr></table></figure></p><p>然后利用sorted对deck进行了排序，因为tuple是不可变的，sorted函数只是对重新申请了新的物理空间来储存排序后的tuple，原始值没有改变。<br>关于洗牌的问题等到读完第十一章再回来解决。</p><h4 id="1-2-如何使用特殊方法"><a href="#1-2-如何使用特殊方法" class="headerlink" title="1.2 如何使用特殊方法"></a>1.2 如何使用特殊方法</h4><blockquote><p>特殊方法的存在是为了被Python的编译器调用，自己并不需要调用他们。像列表、字符串、字节序列这样的Python内置类型，CPython会抄个近路（CPython即用C语言实现Python及其解释器），__len__实际上会直接返回PyVarObject里的ob_size属性。PyVarObject是表示内存中长度可变的内置对象的C语言结构体。直接读取这个值比调用一个方法要快得多。<br>通常你的代码无需直接使用特殊方法。除非有大量的元编程存在，直接调用特殊方法的频率应该远远低于你去实现它们的次数（__init__例外）  </p></blockquote><p>这些特殊方法名能让你自己的对象实现和支持以下的语言架构，并与之交互：  </p><ul><li>迭代</li><li>集合类</li><li>属性访问</li><li>运算符加载</li><li>函数和方法的调用</li><li>对象的创建和销毁</li><li>字符串表示形式和格式化</li><li>管理上下文（即with块）</li></ul><p>之前的扑克牌我们已经见识过了其中的一些，接下来我们会再用一个例子来看看运算符加载和字符串表示形式的格式化。</p><blockquote><p>示例 1-2   一个简单的二维向量类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">    self.x = x</span><br><span class="line">    self.y = y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Vector(%r, %r)'</span> % (self.x, self.y)</span><br><span class="line">    <span class="comment">#repr把一个对象用字符串的形式表示出来，这就是“字符串表示形式”</span></span><br><span class="line">    <span class="comment">#如果没有实现repr，得到的字符串可能会是&lt;Vactor object at 0x10e100070&gt;</span></span><br><span class="line">    <span class="comment"># ‘%’符合和str.format均可用来进行字符串格式化</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hypot(self.x, self.y) <span class="comment">#不接受字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(abs(self)) <span class="comment">#不接受字符串</span></span><br><span class="line">    <span class="comment">#return bool(self.x or self.y) 更搞笑的的写法</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    x = self.x + other.x</span><br><span class="line">    y = self.y + other.y</span><br><span class="line">    <span class="keyword">return</span> Vector(x, y) <span class="comment">#返回新创建的对象</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar) <span class="comment">#返回新创建的对象</span></span><br></pre></td></tr></table></figure><blockquote><p>__repr__ 和 __str__ 的区别在于,后者是在 str() 函数被使用,或是在用 print 函数<br>打印一个对象的时候才被调用的,并且它返回的字符串对终端用户更友好。<br>如果你只想实现这两个特殊方法中的一个,__repr__ 是更好的选择,因为如果一个对象<br>没有 __str__ 函数,而 Python 又需要调用它的时候,解释器会用 __repr__ 作为替代。</p></blockquote><p>对于算术运算符，中缀运算符的基本原则就是<strong>不改变操作对象</strong>，而是产出一个新的值；<br>对于布尔值，bool（x）的背后是调用x.__bool__(),若没有则尝试调用x.__len__()</p><h4 id="1-4-为什么len不是普通方法"><a href="#1-4-为什么len不是普通方法" class="headerlink" title="1.4 为什么len不是普通方法"></a>1.4 为什么len不是普通方法</h4><p><strong>实用胜于纯粹</strong>,为了让Python自带的数据结构可以走后门，<br>保持内置类型的效率同时保证了一致性之间，这样的设计印证了<strong>不能让特例特殊到开始破坏既定规则</strong>的原则</p><h4 id="1-5-本章小结"><a href="#1-5-本章小结" class="headerlink" title="1.5 本章小结"></a>1.5 本章小结</h4><ol><li>实现特殊方法使得自定义数据类型可以表现得像内置类型一样</li><li>Python对象的一个基本要求就是它得有合理的字符串表示形式</li></ol><h3 id="第2章-序列构成的列表"><a href="#第2章-序列构成的列表" class="headerlink" title="第2章 序列构成的列表"></a>第2章 序列构成的列表</h3><p>容器序列：<br>list、tuple 和collections.deque这些序列能存放不同类型的数据。<br>扁平序列：<br>str、bytes、bytearray、memoryview和array.array，这类序列只能容纳一种类型。</p><p>可变序列（MutableSequence）：<br>list、bytearray、array.array、collections.deque和memoryview<br>不可变序列（Sequence）：<br>tuple、str和bytes  </p><h4 id="列表推导和生成器表达式"><a href="#列表推导和生成器表达式" class="headerlink" title="列表推导和生成器表达式"></a>列表推导和生成器表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbols = <span class="string">'$%^*&amp;'</span></span><br><span class="line">codes = [ord(sybol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols]</span><br><span class="line">print(codes)</span><br></pre></td></tr></table></figure><p><strong><em>PS:只用列表推导来创建新的列表，并且尽量保持简短。</em></strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Python 2.7.6 (default, Mar 22 2014, 22:59:38)</span><br><span class="line">[GCC 4.8.2] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; x = &apos;my precious&apos;</span><br><span class="line">&gt;&gt;&gt; dummy = [x for x in &apos;ABC&apos;]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">&apos;C&apos;</span><br></pre></td></tr></table></figure><p>python3中列表推导不会再有变量泄漏的问题</p><p>虽然也可以用列表推导来初始化元组、数组或其他序列类型，但是生成器表达式是更好的选择。这是因为生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。前面那种方式显然能够节省内存。<br>生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已。  </p><p>有些Python 入门教程把元组称为“不可变列表”，然而这并没有完全概括元组的特点。除了用作不可变的列表，它还可以用于没有字段名的记录。<br><strong>元组拆包，嵌套元组拆包，具名元组</strong>  </p><blockquote><p>为什么切片和区间会忽略最后一个元素?<br>• 当只有最后一个位置信息时，我们也可以快速看出切片和区间里有几个元素：range(3)和my_list[:3] 都返回3 个元素。<br>• 当起止位置信息都可见时，我们可以快速计算出切片和区间的长度，用后一个数减去第一个下标（stop - start）即可。<br>• 这样做也让我们可以利用任意一个下标来把序列分割成不重叠的两部分，只要写成my_list[:x] 和my_list[x:] 就可以了</p></blockquote><h3 id="第4章-文本和字节序列"><a href="#第4章-文本和字节序列" class="headerlink" title="第4章 文本和字节序列"></a>第4章 文本和字节序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">人类使用文本，计算机使用字节序列。</span><br><span class="line">——Esther Nam 和Travis Fischer</span><br><span class="line">“Character Encoding and Unicode in Python”</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行了一些Leetcode的练习后发觉，python相比我之前学习的C、Java更为方便，如沐春风，不管是从数据结构还是从设计的哲学，我体会到了Python语言的强大，买来一本《Fluent Python》，希望自己在读完后有更深刻的理解&lt;/p&gt;
&lt;h2 id=&quot;第一部分
      
    
    </summary>
    
    
      <category term="Python，Reading Notes" scheme="https://myaath.github.io/categories/Python%EF%BC%8CReading-Notes/"/>
    
    
      <category term="Python" scheme="https://myaath.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro安装配置及Chrome插件推荐</title>
    <link href="https://myaath.github.io/2017/12/28/Manjaro%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8AChrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>https://myaath.github.io/2017/12/28/Manjaro%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8AChrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</id>
    <published>2017-12-28T03:55:11.000Z</published>
    <updated>2019-12-31T05:38:26.716Z</updated>
    
    <content type="html"><![CDATA[<p>第一次写博客，记录下自己的成长经历</p><p>archlinux是一个可定制性极高的版本，之前尝试过，单是安装过程就让我收获良多，不过因为对一个全新的版本不熟悉，需要使用一个易用的操作系统，直接换回了win10。但是win10上使用命令行实在是麻烦，各种不舒服，便安装了win10和Manjaro的双系统，本文记录了我安装Manjaro的过程，同时给出自己在使用Chrome的一些插件。</p><h3 id="Manjaro安装"><a href="#Manjaro安装" class="headerlink" title="Manjaro安装"></a>Manjaro安装</h3><p>下载<a href="https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/release/" target="_blank" rel="noopener">Manjaro镜像</a>,根据自己想要安装的桌面来选择镜像，这里我选择了Gnome桌面版<br>下载USBWriter，将镜像文件刻录到U盘中<br>重启电脑，进入BIOS，选择从U盘中启动，按照提示进入安装界面，根据自己的喜好选择语言、时区等配置选项，这里想特别说一下，不管是选择操作系统语言还是创建文件夹，最好使用英文，否则会出一些莫名其妙的问题。当然，对于Manjaro，安装好后是可以再换语言的。完成一些基本的配置后，会进入分区的配置界面，这里我因为是双系统，选择将引导安装到硬盘里，设置好用户名密码之后，进入安装界面，稍等片刻即可。<br>拔掉U盘，选择Manjaro系统，至此完成安装。</p><h3 id="Manjaro配置"><a href="#Manjaro配置" class="headerlink" title="Manjaro配置"></a>Manjaro配置</h3><h4 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h4><p>打开终端输入  </p><p><code>sudo nano /etc/pacman.conf</code></p><p>在文件底部加入：</p><blockquote><p>[archlinuxcn]<br>SigLevel = Optional TrustedOnly<br>Server = <a href="https://mirrors.ustc.edu.cn/archlinuxcn/$arch" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/archlinuxcn/$arch</a></p></blockquote><p>再执行<code>sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring</code>  </p><p><strong> 从这里开始，软件都可以在Package Manager中搜索安装，但部分软件仍需配置 </strong></p><h4 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-sogoupinyin</span><br><span class="line">sudo pacman -S fcitx-im  <span class="comment">#全部安装</span></span><br><span class="line">suao pacman -S fcitx-configtool  <span class="comment">#图形化配置工具</span></span><br></pre></td></tr></table></figure><p>设置中文输入法环境变量，否则中文输入法无法启动，同样在终端输入：</p><p><code>sudo nano ~/.xprofile</code>  </p><p>在文件底部加入：</p><blockquote><p>export GTK_IM_MODULE=fcitx<br>export QT_IM_MODULE=fcitx<br>export XMODIFIERS=”@im=fcitx”</p></blockquote><h4 id="Chrome浏览器"><a href="#Chrome浏览器" class="headerlink" title="Chrome浏览器"></a>Chrome浏览器</h4><p><code>sudo pacman -S google-chrome</code></p><h4 id="TIM"><a href="#TIM" class="headerlink" title="TIM"></a>TIM</h4><p><code>yaourt -S deepin-wine-tim</code></p><h4 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h4><p>如果想使用微信，没有特别好的方法，我是在Chrome中打开微信网页版,在Chrome的<code>More tools</code>选择<code>Add to desktop</code>即可</p><h4 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h4><p><code>sudo pacman -S shadowsocks-qt5</code></p><h4 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h4><p><code>sudo pacman -S netease-cloud-music</code></p><h4 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h4><p><code>sudo pacman -S wps-office</code></p><h3 id="Manjaro美化"><a href="#Manjaro美化" class="headerlink" title="Manjaro美化"></a>Manjaro美化</h3><p><img src="/images/desktop.png" alt="Image"></p><p>这是我目前的桌面<br><strong>接下来说一下在Gnome中的各种主题以及Gnome shell扩展</strong></p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>Application:<code>Arc</code><br>Cursor:<code>Xcursor-breeze</code><br>Icons:<code>Numix-Circle-Light</code><br>Shell:<code>Adapta-Nokto-Eta-Maia</code></p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>Dash to dock：底部工具栏（配置如图）<br><img src="/images/setting.png" alt="Image"><br>Hide top bar:智能隐藏顶栏<br>Openweather：显示天气<br>还有一些插件是Manjaro自带的，根据自己的喜好配置就可以了</p><h3 id="Chrome插件推荐"><a href="#Chrome插件推荐" class="headerlink" title="Chrome插件推荐"></a>Chrome插件推荐</h3><p><strong>最后再推荐一些自己Chrome上使用的插件</strong>  </p><p>Adblock Plus：屏蔽广告<br>Chrono Download Manager：下载管理<br>Google Translate：谷歌翻译插件，可以划词翻译，很方便<br>Momentum：代替新建标签页，每日换背景<br>Proxy SwitchOmega：设置代理<br>Take Webpage Screenshots Entirely - FireShot：强大的截图工具<br>Vimium：The Hacker’s Browser</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次写博客，记录下自己的成长经历&lt;/p&gt;
&lt;p&gt;archlinux是一个可定制性极高的版本，之前尝试过，单是安装过程就让我收获良多，不过因为对一个全新的版本不熟悉，需要使用一个易用的操作系统，直接换回了win10。但是win10上使用命令行实在是麻烦，各种不舒服，便安装了
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://myaath.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://myaath.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
